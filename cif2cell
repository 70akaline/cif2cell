#!/usr/bin/env python
# Copyright 2010 Torbjorn Bjorkman
# This file is part of cif2cell
#
# cif2cell is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cif2cell is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cif2cell.  If not, see <http://www.gnu.org/licenses/>.
#
#**********************************************************************************
#  Description: A command-line tool to generate the geometrical setup
#               for various electronic structure codes from a CIF format file.
#  Author: Torbjorn Bjorkman
#  Affiliation: COMP, Aaalto University School of
#               Science and Technology, Department of
#               Applied Physics, Espoo, Finland
#  Revision history:
#      2010-07-13 Torbjorn Bjorkman
#        - First version branched off from cellfromcif.
#      2010-07-14 Torbjorn Bjorkman
#        - Fixed reduction to primitive cell (really seems to work this time!).
#      2010-07-15 Torbjorn Bjorkman
#        - Moving stuff over to objects in uctools module.
#      2010-07-18 Torbjorn Bjorkman
#        - Things now moved to uctools.
#        - Output for kgrn, kfcd and ncol added.
#      2010-08-20 Torbjorn Bjorkman
#        - Space group information (positions and H-M symbol) no longer
#          required in CIF file.
#        - Added output for ABINIT.
#      2010-08-22 Torbjorn Bjorkman
#        - Added output for Siesta.
#      2010-08-23 Torbjorn Bjorkman
#        - Added output for CPMD.
#      2010-08-23 Torbjorn Bjorkman
#        - Added output for CASTEP.
#      2010-08-26 Torbjorn Bjorkman
#        - Added output for Fleur.
#      2010-09-02 Torbjorn Bjorkman
#        - Added output for exciting.
#      2010-10-01 Torbjorn Bjorkman
#        - Added output of new CIF file with all atoms explicitly written (no reduction of cell!)
#      2010-12-11 Torbjorn Bjorkman
#        - Added supercell generation (primitive version).
#      2011-01-14 Torbjorn Bjorkman
#        - Added possibility of vacuum padding to supercell generation.
#      2011-01-19 Torbjorn Bjorkman
#        - Added translation vector to supercell generation.
#
# TODO:
#   - More formats (always...)
#   - No way of setting output file names for emto and ncol.
#   - Add "full" supercell generation (with full matrix instead of just diagonal elements).
#
# KNOWN BUGS:
#************************************************************************************
from __future__ import division
import os
import sys
import string
from math import *
from datetime import datetime
from optparse import OptionParser, OptionGroup
import warnings
from uctools import *
import CifFile
import subprocess

# Turn of warnings about deprecated stuff
warnings.simplefilter("ignore",DeprecationWarning)
#
# INPUT OPTIONS
# General stuff
description = "A program for generating input lattice structures to various electronic structure programs from a CIF (Crystallographic Information Framework) file."
usage = "usage: %prog -f FILE [-p PROGRAM] [other options]"
parser = OptionParser(usage=usage, description=description)
parser.add_option("-v","--verbose",dest="verbose",help="Print a lot of extra information to screen",action="store_true")
parser.add_option("--version",dest="version",help="Print version number.",action="store_true")
parser.add_option("-q","--quiet",dest="quiet",help="Suppress most screen output, such as warnings and overrides --verbose flag, but will print all other requested output.",action="store_true")
parser.add_option("-f","--file",dest="file",help="Input CIF file",metavar="FILE")
parser.add_option("-p","--program",dest="program",help="The electronic structure code you want to create input file(s) for. Currently supports: abinit, cpmd, cellgen, crystal09, elk, emto, exciting, fleur, ncol, rspt, siesta, spacegroup, vasp. This keyword is case insensitive.")
parser.add_option("-o","--outputfile",dest="outputfile",help="Name of output file (if other than default for you electronic structure code).",metavar="FILE")
parser.add_option("-a","--append",dest="append",help="Append the output to given output file rather than overwriting.",action="store_true")
parser.add_option("--grammar",dest="grammar",help="Set the CIF grammar to be used when parsing the input file (default is 1.1).")
parser.add_option("--which-filename",dest="filenamequery",help="If given together with the --program-name option, the name of the output file will be printed to screen.",action="store_true")
parser.add_option("-b","--block",dest="block",help="Block of data in input file (if there are more than one block in the CIF file).")
parser.add_option("--force-alloy",dest="forcealloy",help="Force generation of output file for an alloy compound for an electronic structure code that does not implement any alloy theory (such as CPA).",action="store_true")
parser.add_option("--coordinate-tolerance",dest="coordtol",help="Parameter for determining when two coordinates are the same (default=0.0002).")
# Printing to screen
parser.add_option("--print-digits",dest="printdigits",help="Number of digits used when printing coordinates etc. to screen (default=8). Useful if you need to tweak the screen output for cutting and pasting into some unsupported program. There is no point in going over 16 because of the floating point accuracy.")
parser.add_option("--print-atomic-units",dest="printau",help="Output lattice parameters in bohrradii rather than angstrom.",action="store_true")
parser.add_option("--print-cartesian",dest="printcart",help="Atomic sites printed to screen in cartesian rather than lattice coordinates.",action="store_true")
# CELL GENERATION OPTIONS
#cellgenopts = OptionGroup(parser, "Cell generation options")
parser.add_option("--no-reduce",dest="noreduce",help="Do not reduce to the primitive cell.",action="store_true")
# Supercell options
parser.add_option("--supercell",dest="supercellmap",help="Three integers separated with commas and enclosed in square brackets that specify the dimensions of a supercell to be constructed from the primitive cell. If combined with the --no-reduce option the supercell will instead be generated based on the conventional cell.",metavar="[k,l,m]")
parser.add_option("--supercell-vacuum",dest="supercellvacuum",help="Three numbers >=0 separated with commas and enclosed in square brackets that specify a number of unit cell units of vacuum to be added along the first, second or third of the generated lattice vectors.",metavar="[k,l,m]")
parser.add_option("--supercell-translation-vector",dest="supercelltransvec",help="Three numbers separated with commas and enclosed in square brackets that specify a final shift of all atomic positions in the final cell (in units of the lattice vectors of the original cell).",metavar="[k,l,m]")
# PROGRAM SPECIFIC OPTIONS
progspec = OptionGroup(parser, "Program specific options")
# emto
progspec.add_option("--emto-hard-sphere-radii",dest="hardsphereradii",help="Set hard spheres in KSTR to something other than the default (=0.67).")
# RSPt
progspec.add_option("--rspt-new", dest="newsymt", help="Generate a symt.inp file in the new format.", action="store_true")
# cellgen
progspec.add_option("--cellgen-map",dest="cellgenmap",help="Nine integers separated with commas and enclosed three and three in square brackets (this is a matrix in Python) that specify the map to a supercell to be output for the RSPt supercell generator 'cellgen'. Overrides --cellgen-supercell-dims.",metavar="[[k,l,m],[n,o,p],[q,r,s]]")
progspec.add_option("--cellgen-supercell-dimensions",dest="cellgensupercelldims",help="Three integers separated with commas and enclosed in square brackets that specify the dimensions of a supercell to be output to the RSPt supercell generator 'cellgen' (the diagonal elements of the 'map').",metavar="[k,l,m]")
progspec.add_option("--cellgen-reference-vector",dest="cellgenrefvec",help="Three reals separated with commas and enclosed in square brackets that specify an optional shift of the origin used by the RSPt supercell generator 'cellgen'.",metavar="[x,y,z]")
# CPMD
progspec.add_option("--cpmd-cutoff",dest="cpmdcutoff",help="Set the cutoff written to the &SYSTEM block (default=100.0 Ry).")
# spacegroup
progspec.add_option("--spacegroup-supercell",dest="spacegroupsupercell",help="Three integers separated with commas and enclosed in square brackets that specify the dimensions of a supercell to be output to the elk input generator 'spacegroup'.",metavar="[k,l,m]")
# VASP
progspec.add_option("--vasp-print-species",dest="vaspprintspcs",help="Print the atomic species to screen in the order they are put in the POSCAR file (useful for scripting).",action="store_true")
progspec.add_option("--vasp-cartesian",dest="vaspcart",help="Write lattice vectors and positions to POSCAR file in cartesian coordinates and set length to 1.",action="store_true")
progspec.add_option("--vasp-cartesian-lattice-vectors",dest="vaspcartvecs",help="Write lattice vectors to POSCAR file in cartesian coordinates and set the length scale to 1.",action="store_true")
progspec.add_option("--vasp-cartesian-positions",dest="vaspcartpos",help="Write atomic positions to POSCAR file in Cartesian rather than Direct coordinates.",action="store_true")
parser.add_option_group(progspec)
(options,args) = parser.parse_args()

# own name
programname = "cif2cell"
version = "0.1.1"
if options.version:
    print programname+" version "+version
    sys.exit(0)

# Electronic structure program
if options.program:
    outputprogram = options.program.lower()
else:
    outputprogram = None

# recast some input parameters
if options.noreduce or outputprogram == "cif":
    reducetoprim = False
else:
    reducetoprim = True

# Set verbosity level
if options.verbose and not options.quiet:
    verbose = True
else:
    verbose = False

# Various parameters
# Programs that can deal with alloys
alloyprograms = set(["emto","kstr","bmdl","shape","kgrn","kfcd","cif"])
# Initialize element data
ed = ElementData()
# Number of positions for printing decimal numbers to screen
if type(options.printdigits) == type(None):
    decpos = 8 + 3
else:
    decpos = int(options.printdigits) + 3
# format string for outputting decimal numbers to screen
decform = "%"+str(decpos)+"."+str(decpos-4)+"f"
threedecs = " "+decform+" "+decform+" "+decform
# For printing time
today = datetime.today()
datestring = str(today.year)+"-"+str(today.month).rjust(2,'0')+"-"+str(today.day).rjust(2,'0')+' '+str(today.hour)+":"+str(today.minute).rjust(2,'0')

# Open and read CIF file
if options.file:    
    # input CIF file
    cif_file = options.file
    # Set CIF grammar
    if options.grammar:
        cif_grammar = options.grammar
    else:
        cif_grammar = '1.1'
    # Skip validation for now... it causes too much trouble.
#    cdic = CifFile.CifDic("cif_core.dic",grammar='1.1')     
#    val_results = CifFile.validate(cif_file,dic=cdic)
#    print validate_report(val_results)
#    val_report = CifFile.ValidationResult(val_results)
    try:
        cf = CifFile.CifFile(cif_file,grammar=cif_grammar)
    except IOError:
        sys.stderr.write("***Error: The file "+cif_file+" could not be found.\n")
        sys.exit(2)
    except:
        sys.stderr.write("***Error: could not read "+cif_file+".\n")
        sys.exit(2)
else:
    sys.stderr.write("***Error: No input CIF file given\n")
    sys.exit(2)

# Make supercell?
if options.supercellmap or options.supercellvacuum or options.supercelltransvec:
    makesupercell = True
    if options.supercellmap:
        supercellmap = eval(options.supercellmap)
    else:
        supercellmap = [1,1,1]
    if options.supercellvacuum:
        supercellvacuum = eval(options.supercellvacuum)
    else:
        supercellvacuum = [0,0,0]
    if options.supercelltransvec:
        supercelltransvec = eval(options.supercelltransvec)
    else:
        supercelltransvec = [0,0,0]
else:
    makesupercell = False

##############################################
# Get blocks
cfkeys = cf.keys()
if options.block:
    cb = cf.get(options.block)
    if type(cb) == type(None):
        sys.stderr.write("***Error: No block "+options.block+" in "+cif_file+".\n")
        sys.exit(2)
else:
    cb = cf.get(cfkeys[0])
# Get reference data
ref = ReferenceData()
ref.getFromCIF(cb)
# Get cell data
cd = CellData()
# suppress warnings if requested
cd.quiet = options.quiet
if options.coordtol:
    cd.coordepsilon = float(options.coordtol)
try:
    cd.getFromCIF(cb)
except PositionError, e:
    sys.stderr.write("***Error: cell setup: "+e.value+"\n")
    sys.exit(2)
except CellError, e:
    sys.stderr.write("***Error: cell setup: "+e.value+"\n")
    sys.exit(2)
    
##############################################
# Generate cell
if reducetoprim:
    try:
        cell = cd.primitive()
    except SymmetryError, e:
        sys.stderr.write("***Error: cell setup: "+e.value+"\n")
        sys.exit(2)
else:
    try:
        cell = cd.conventional()
    except SymmetryError, e:
        sys.stderr.write("***Error: cell setup: "+e.value+"\n")
        sys.exit(2)
# Print cell
if verbose or not options.program and not options.quiet:
    print string.upper(programname)+" "+version
    print datestring
    print "Output for "+ref.cpd+" ("+ref.compound+")"
    print ref.databasestring
    if cell.alloy and options.forcealloy and options.program:
        print "\nEnforcing generation of file(s) for "+outputprogram+" for an alloy."
    print "\n BIBLIOGRAPHIC INFORMATION"
    print ref.referencestring()
    print "\n SYMMETRY INFORMATION"
    if cd.spacegroupnr >= 0:
        print "Space group number "+": ".rjust(len(cd.spacegroupsymboltype)+2)+str(cd.spacegroupnr)
        print "Space group symbol "+cd.spacegroupsymboltype+": "+cd.spacegroupsymbol
        print "This system is "+cd.crystal_system()+"."
    else:
        print "No space group information found."
    # only print these if verbose
    if verbose:
        print "Symmetry equivalent sites:"
        for i in range(len(cd.eqsites)):
            print "%4i  %8s, %8s, %8s" % (i+1, cd.eqsites[i][0], cd.eqsites[i][1], cd.eqsites[i][2])
    print "\n INPUT CELL INFORMATION"
    print "Lattice parameters:"
    tmpstring = ""
    for i in ["a", "b", "c"]:
        tmpstring += i.rjust(decpos)+" "
    print tmpstring
    formatstring = ""
    if options.printau:
        aprint = cd.a*angtobohr
        bprint = cd.b*angtobohr
        cprint = cd.c*angtobohr
    else:
        aprint = cd.a
        bprint = cd.b
        cprint = cd.c
    for i in range(3):
        formatstring = formatstring+decform+" "
    print formatstring % (aprint, bprint, cprint)
    tmpstring = ""
    for i in ["alpha", "beta", "gamma"]:
        tmpstring += i.rjust(decpos)+" "
    print tmpstring
    print formatstring % (cd.alpha, cd.beta, cd.gamma)
    # Pretty printing in columns that need to have variable width
    # w1 = width of the atomic species column
    # w2 = width of a decimal column
    # w3 = width of the occupancy column
    if cell.alloy:
        w1 = 0
        # Find atom column width
        for site in cell.sitedata:
            tmpstring = ""
            for k in site[1]:
                tmpstring += k+"/"
            tmpstring = tmpstring.rstrip("/")
            w1 = max(w1,len(tmpstring))
        w1 = w1 + 1
        # find occupation column width
        w3 = 0
        for site in cell.sitedata:
            tmpstring = ""
            for (k,v) in site[1].iteritems():
                tmpstring += str(v).rstrip('0.')+"/"
            tmpstring = tmpstring.rstrip("/")
            w3 = max(w3,len(tmpstring))
        # small aesthetic adjustment 
        w3 = w3 + 2
    else:
        w1 = 5
        w2 = decpos
        w3 = 0
    tmpstring = "Representative sites "
    if options.printcart:
        tmpstring += "(cartesian coordinates):"
    else:
        tmpstring += "(lattice coordinates):"
    print tmpstring
    siteheader = "Atom".ljust(w1)+" "
    if options.printcart:
        transmtx = []
        for i in range(3):
            transmtx.append([])
            for j in range(3):
                transmtx[i].append(cell.latticevectors[i][j]*cd.a)
            i += 1
        for i in ["x","y","z"]:
            siteheader += i.rjust(decpos)+" "
    else:
        transmtx = [[1, 0, 0],
                    [0, 1, 0],
                    [0, 0, 1]]
        for i in ["a1","a2","a3"]:
            siteheader += i.rjust(decpos)+" "
    if cell.alloy:
        if w3 > 13:
            siteheader += "occupancies".rjust(w3)
        else:
            siteheader += "occ.".rjust(w3)
    print siteheader
    # Representative sites
    for site in cell.sitedata:
        tmpstring = ""
        for k in site[1]:
            tmpstring += k+"/"
        tmpstring = tmpstring.rstrip("/")
        v = [site[0][0],site[0][1],site[0][2]]
        v = mvmult3(transmtx,v)
        tmpstring = tmpstring.ljust(w1) + threedecs % (v[0], v[1], v[2])
        if cell.alloy:
            occstring = ""
            for (k,v) in site[1].iteritems():
                occstring += str(v).rstrip('0.') + "/"
            occstring = occstring.rstrip("/")
            tmpstring += " "+occstring.rjust(w3)
        print tmpstring
    print "\n OUTPUT CELL INFORMATION"
    tmpstring = "Bravais lattice vectors :"
    if options.printcart:
        fact = cd.a
    else:
        fact = 1
    print tmpstring
    formatstring = ""
    for i in range(3):
        formatstring = formatstring+decform+" "
    for i in range(3):
        print formatstring % (cell.latticevectors[i][0]*fact, cell.latticevectors[i][1]*fact, cell.latticevectors[i][2]*fact)
    # Print out all sites
    tmpstring = "All sites, "
    if options.printcart:
        tmpstring += "(cartesian coordinates):"
    else:
        tmpstring += "(lattice coordinates):"
    print tmpstring
    print siteheader
    for site in cell.sitedata:
        spcsstring = ""
        for k in site[1]:
            spcsstring = spcsstring+k+"/"
        spcsstring = spcsstring.rstrip("/")
        occstring = ""
        if cell.alloy:
            for (k,v) in site[1].iteritems():
                occstring = occstring + str(v).rstrip('0.') + "/"
            occstring = occstring.rstrip("/")
        for j in range(len(site[2])):
            v = mvmult3(transmtx,site[2][j])
            tmpstring = spcsstring.ljust(w1)+threedecs % (v[0], v[1], v[2])
            tmpstring += " "+occstring.rjust(w3)
            print tmpstring

##############################################
# Generate supercell
if makesupercell:
    try:
        supercell = cd.getSuperCell(supercellmap,supercellvacuum,supercelltransvec)
    except CellError, e:
        sys.stderr.write("***Error: Supercell setup: "+e.value+"\n")
        sys.exit(2)
    # Print supercell
    if verbose or not options.program and not options.quiet:
        print "\n SUPERCELL INFORMATION"
        tmpstring = "Bravais lattice vectors :"
        if options.printcart:
            fact = cd.a
        else:
            fact = 1
        print tmpstring
        formatstring = ""
        for i in range(3):
            formatstring = formatstring+decform+" "
        for i in range(3):
            print formatstring % (supercell.latticevectors[i][0]*fact, supercell.latticevectors[i][1]*fact, supercell.latticevectors[i][2]*fact)
        # Print out all sites
        tmpstring = "All sites, "
        if options.printcart:
            tmpstring += "(cartesian coordinates):"
        else:
            tmpstring += "(lattice coordinates):"
        print tmpstring
        print siteheader
        for site in supercell.sitedata:
            spcsstring = ""
            for k in site[1]:
                spcsstring = spcsstring+k+"/"
            spcsstring = spcsstring.rstrip("/")
            occstring = ""
            if supercell.alloy:
                for (k,v) in site[1].iteritems():
                    occstring = occstring + str(v).rstrip('0.') + "/"
                occstring = occstring.rstrip("/")
            for j in range(len(site[2])):
                v = mvmult3(transmtx,site[2][j])
                tmpstring = spcsstring.ljust(w1)+threedecs % (v[0], v[1], v[2])
                tmpstring += " "+occstring.rjust(w3)
                print tmpstring
    # update to the supercell
    cell = supercell

##############################################
# Sort sites so that the ones occupied by the heaviest elements come first,
# if the Python version supports this form of the max function and there is
# nothing wrong with the site data.
try:
    cell.sitedata.sort(key = lambda site: ed.elementnr[max(site[1], key = site[1].get)], reverse=True)
except:
    pass

##############################################
# Output file mode (overwrite or append?)
if options.append:
    outmode = "a"
else:
    outmode = "w"
# Output file. ot parsed until this point, since the default file names for some of
# the codes contain the names of space group and compound.
if options.outputfile:
    outputfile = options.outputfile
else:
    # Default output filenames for different programs
    if outputprogram == "vasp":
        outputfile = "POSCAR"
    elif outputprogram == "rspt":
        outputfile = "symt.inp"
        if options.newsymt:
            newsymtformat = True
        else:
            newsymtformat = False
    elif outputprogram == "cellgen":
        outputfile = "cellgen.inp"
    elif outputprogram == "elk":
        outputfile = "GEOMETRY.OUT"
    elif outputprogram == "exciting":
        outputfile = "input.xml"
    elif outputprogram == "spacegroup":
        outputfile = "spacegroup.in"
    elif outputprogram == "abinit":
        outputfile = ref.cpd.replace(" ", "").replace("(","").replace(")","")
        # If the filename seems too long, replace by the name of the cif file
        if len(outputfile) > 10:
            if len(cif_file) < len(outputfile):
                outputfile = cif_file.replace(".cif","")
            else:
                outputfile = outputfile[0:9]
        outputfile = outputfile+".in"
    elif outputprogram == "siesta":
        outputfile = ref.cpd.replace(" ", "").replace("(","").replace(")","")
        # If the filename seems too long, replace by the name of the cif file
        if len(outputfile) > 10:
            if len(cif_file) < len(outputfile):
                outputfile = cif_file.replace(".cif","")
            else:
                outputfile = outputfile[0:9]
        outputfile = outputfile+".fdf"
    elif outputprogram == "cpmd":
        outputfile = ref.cpd.replace(" ", "").replace("(","").replace(")","")
        # If the filename seems too long, replace by the name of the cif file
        if len(outputfile) > 10:
            if len(cif_file) < len(outputfile):
                outputfile = cif_file.replace(".cif","")
            else:
                outputfile = outputfile[0:9]
        outputfile = outputfile+".inp"
    elif outputprogram == "castep":
        outputfile = ref.cpd.replace(" ", "").replace("(","").replace(")","")
        # If the filename seems too long, replace by the name of the cif file
        if len(outputfile) > 10:
            if len(cif_file) < len(outputfile):
                outputfile = cif_file.replace(".cif","")
            else:
                outputfile = outputfile[0:9]
        outputfile = outputfile+".cell"
    elif outputprogram == "fleur":
        outputfile = ref.cpd.replace(" ", "").replace("(","").replace(")","")
        # If the filename seems too long, replace by the name of the cif file
        if len(outputfile) > 10:
            if len(cif_file) < len(outputfile):
                outputfile = cif_file.replace(".cif","")
            else:
                outputfile = outputfile[0:9]
        outputfile = "inp_"+outputfile
    elif outputprogram == "crystal09":
        outputfile = ref.cpd.replace(" ", "").replace("(","").replace(")","")
        # If the filename seems too long, replace by the name of the cif file
        if len(outputfile) > 10:
            if len(cif_file) < len(outputfile):
                outputfile = cif_file.replace(".cif","")
            else:
                outputfile = outputfile[0:9]
        # This is the naming convention from a large bunch of test cases, no idea why
        outputfile = outputfile+".d12"
    elif outputprogram == "cif":
        outputfile = cif_file.replace(".cif","")+"_allatoms.cif"
    else:
        outputfile = ""

# Print output filename to screen
if outputprogram !="":
    if (verbose or options.filenamequery) and outputfile != "":
        print "Data will be written to the file "+outputfile

################################################################################################
# stuff that should be printed irrespective of the verbose flag
if cell.alloy and options.forcealloy and options.program and not verbose:
    tmpstring = "Enforcing file generation for alloy. "
    if outputprogram == 'bstr' or outputprogram == 'vasp' or outputprogram == 'cpmd':
        print tmpstring
    else:
        tmpstring += "Warning! The file(s) will be incomplete!"
        print tmpstring
    
################################################################################################
# Stop here if no specific output was requested
if not options.program:
    sys.exit(0)

# Don't generate output for alloys (for most programs)
if cell.alloy and not options.forcealloy and not outputprogram in alloyprograms:
    print "Error: This system is an alloy, but the electronic structure code "+outputprogram+" has no way of dealing with alloys.\nRun again with --force-alloy if you want to generate an (incomplete) output file anyway."
    sys.exit(17)

# Function for printing a standard docstring
def StandardDocstring():
    stringlen = max(len(ref.referencestring()),len(ref.cpd+"   ("+ref.compound+")"))
    docstring = ""
    tmpstring = ""
    tmpstring = tmpstring.ljust(stringlen+4,'*')+'\n'
    docstring += tmpstring
    tmpstring2 = 'Generated by '+programname+' '+version+' '+datestring
    tmpstring2 = '* '+tmpstring2.center(stringlen)+' *\n'
    docstring += tmpstring2
    if ref.database != "":
        tmpstring2 = 'Data obtained from '+ref.databaseabbr[ref.database]
        if ref.databasecode != "":
            tmpstring2 += ". Reference number : "+ref.databasecode
        tmpstring2 = '* '+tmpstring2.center(stringlen)+' *\n'
        docstring += tmpstring2
    tmpstring2 = ref.cpd+"   ("+ref.compound+")"
    tmpstring2 = '* '+tmpstring2.center(stringlen)+' *\n'
    docstring += tmpstring2
    docstring += '* '+ref.referencestring().center(stringlen)+' *\n'
    docstring += tmpstring
    return docstring

################################################################################################
# Output cell to new CIF file
if outputprogram == 'cif':
    f = open(outputfile,'w')
    cf = CifFile.CifFile()
    cb = CifFile.CifBlock()
    # Cell parameters
    cb['_cell_length_a'] = cd.a
    cb['_cell_length_b'] = cd.b
    cb['_cell_length_c'] = cd.c
    cb['_cell_angle_alpha'] = cd.alpha
    cb['_cell_angle_beta']  = cd.beta
    cb['_cell_angle_gamma'] = cd.gamma
    cb['_space_group_IT_number'] = cd.spacegroupnr
    if cd.spacegroupsymboltype == "(H-M)":
        cb['_space_group_name_H-M_alt'] = cd.spacegroupsymbol
    elif cd.spacegrousymboltype == "(Hall)":
        cb['_space_group_name_Hall'] = cd.spacegroupsymbol        
    # Positions
    labels = []
    symbols = []
    symmult = []
    fractx = []
    fracty = []
    fractz = []
    occup = []
    for site in cell.sitedata:
        for pos in site[2]:
            for k in site[1]:
                labels.append(k)
                symbols.append(k)
                symmult.append(str(len(site[2])))
                fractx.append(str(pos[0]))
                fracty.append(str(pos[1]))
                fractz.append(str(pos[2]))
                occup.append(str(site[1][k]))
    #
    cb.AddCifItem(([['_atom_site_label',
                    '_atom_site_type_symbol',
                    '_atom_site_symmetry_multiplicity',
                    '_atom_site_fract_x',
                    '_atom_site_fract_y',
                    '_atom_site_fract_z',
                    '_atom_site_occupancy']],
                   [[labels,symbols,symmult,fractx,fracty,fractz,occup]]))
    #
    cf['1-cif2cell'] = cb
    f.write(str(cf))
    f.close()

################################################################################################
# Output for Crystal09
if outputprogram == 'crystal09':
    # Get documentation string
    docstring = StandardDocstring()
    # Get output file object
    crystal09file = Crystal09File(cell, docstring)
    crystal09file.spacegroupnr = cd.spacegroupnr
    crystal09file.a = cd.a
    crystal09file.b = cd.b
    crystal09file.c = cd.c
    crystal09file.alpha = cd.alpha
    crystal09file.beta  = cd.beta
    crystal09file.gamma = cd.gamma
    if cd.crystal_system() == "trigonal":
        # Get rhombohedral cell parameters
        if reducetoprim and abs(cd.gamma-120) < cd.coordepsilon:
            a = sqrt(3*cd.a**2 + cd.c**2)/3
            alpha = 360*asin(3/(2*sqrt(3+(cd.c/cd.a)**2)))/pi
            crystal09file.a = a
            crystal09file.b = a
            crystal09file.c = a
            crystal09file.alpha = alpha
            crystal09file.beta = alpha
            crystal09file.gamma = alpha
            crystal09file.trigonalsetting = "R"
    # Print to file
    f = open(outputfile, outmode)
    f.write(crystal09file.FileString())
    f.close()
    sys.exit(0)

################################################################################################
# Output for Fleur
if outputprogram == 'fleur':
    # The first line with info from the CIF file and species order
    docstring = "Generated by "+programname+" "+version+" : "+ref.cpd+" ("+ref.compound+")"+" :  "+ref.referencestring()
    fleurinput = FleurFile(cell, docstring)
    f = open(outputfile, outmode)
    f.write(fleurinput.FileString())
    f.close()
    
################################################################################################
# Output for CASTEP
if outputprogram == 'castep':
    docstring = StandardDocstring()
    castepinput = CASTEPFile(cell, docstring)
    f = open(outputfile, outmode)
    f.write(castepinput.FileString())
    f.close()
    
################################################################################################
# Output for CPMD
if outputprogram == 'cpmd':
    docstring = StandardDocstring()
    cpmdinput = CPMDFile(cell, docstring)
    f = open(outputfile, outmode)
    f.write(cpmdinput.FileString())
    f.close()
    
################################################################################################
# Output for Siesta
if outputprogram == 'siesta':
    docstring = StandardDocstring()
    siestainput = SiestaFile(cell, docstring)
    f = open(outputfile, outmode)
    f.write(siestainput.FileString())
    f.close()
    
################################################################################################
# Output for ABINIT
if outputprogram == 'abinit':
    docstring = StandardDocstring()
    abinitinput = ABINITFile(cell, docstring)
    f = open(outputfile, outmode)
    f.write(abinitinput.FileString())
    f.close()
    
################################################################################################
# Output for VASP
if outputprogram == 'vasp':
    # The first line with info from the CIF file and species order
    docstring =  "Generated by "+programname+" "+version
    if ref.database != "" and ref.databasecode != "":
        docstring += " from "+ref.databaseabbr[ref.database]+" reference: "+ref.databasecode
    docstring += ". "
    if len(ref.cpd) > len(ref.compound):
        docstring += ref.compound
    else:
        docstring += ref.cpd
    docstring += " :  "+ref.referencestring()+"."
    # Initialize the POSCARFile structure
    poscar = POSCARFile(cell, docstring)
    # Convert to cartesian coordinates if requested
    if options.vaspcartpos:
        poscar.printcartpos = True
    if options.vaspcartvecs:
        poscar.printcartvecs = True
    if options.vaspcart:
        poscar.printcartpos = True
        poscar.printcartvecs = True
    f = open(outputfile, outmode)
    f.write(poscar.FileString())
    f.close()
    # Print species order to screen if requested
    if options.vaspprintspcs:
        print poscar.SpeciesOrder()
    sys.exit(0)
    
################################################################################################
# Output for elk
if outputprogram == 'elk':
    # Get documentation string
    docstring = StandardDocstring()
    # Get output file object
    geometryfile = ElkFile(cell, docstring)
    f = open(outputfile, outmode)
    f.write(geometryfile.FileString())
    f.close()
    sys.exit(0)

################################################################################################
# Output for exciting
if outputprogram == 'exciting':
    # Get documentation string
    docstring = StandardDocstring()
    # Get output file object
    excitingfile = ExcitingFile(cell, docstring)
    f = open(outputfile, outmode)
    f.write(excitingfile.FileString())
    f.close()
    sys.exit(0)

################################################################################################
# Output for spacegroup.in for Elk/Exciting cell utility spacegroup
if outputprogram == 'spacegroup':
    # Get documentation string
    docstring = StandardDocstring()
    # Get output file object
    spacegroupfile = SpacegroupFile(cell, docstring)
    angtobohr = 1e-10 * 4 * pi * 10973731.568527/7.2973525376e-3
    spacegroupfile.HermannMauguin = cd.spacegroupsymbol.replace("/","")
    spacegroupfile.a = cd.a*angtobohr
    spacegroupfile.b = cd.b*angtobohr
    spacegroupfile.c = cd.c*angtobohr
    spacegroupfile.alpha = cd.alpha
    spacegroupfile.beta  = cd.beta
    spacegroupfile.gamma = cd.gamma
    if options.spacegroupsupercell:
        spacegroupfile.supercelldims = eval(options.spacegroupsupercell)
    # Print to file
    f = open(outputfile, outmode)
    f.write(spacegroupfile.FileString())
    f.close()
    sys.exit(0)

################################################################################################
# Output for RSPt
if outputprogram == 'rspt':
    # Construct documentation string
    docstring = StandardDocstring()
    # Get file string and print to symt.inp
    if newsymtformat:
        symtfile = SymtFile2(cell, docstring)
    else:
        symtfile = SymtFile(cell, docstring)
    f = open(outputfile, outmode)
    f.write(symtfile.FileString())
    f.close()
    sys.exit(0)
    
################################################################################################
# Output for RSPt supercell generator cellgen
if outputprogram == 'cellgen':
    # Construct documentation string
    docstring = StandardDocstring()
    # Initialize file object
    cellgenfile = CellgenFile(cell, docstring)
    if options.cellgenrefvec:
        cellgenfile.referencevector = eval(options.cellgenrefvec)
    if options.cellgensupercelldims:
        tmplist = eval(options.cellgensupercelldims)
        tmpmat = []
        for i in range(3):
            tmpmat.append([])
            for j in range(3):
                tmpmat[i].append(0)
            tmpmat[i][i] = tmplist[i]
        cellgenfile.supercellmap = tmpmat
    if options.cellgenmap:
        tmpmat = eval(options.cellgenmap)
        cellgenfile.supercellmap = tmpmat
    # Print to file
    f = open(outputfile, outmode)
    f.write(cellgenfile.FileString())
    f.close()
    sys.exit(0)

################################################################################################
# Output for TB-LMTO program ncol
if outputprogram == 'ncol' or outputprogram == 'bstr':
    # Set up names for files. 
    if cd.spacegroupsymbol == "":
        bstrjobnam = ref.cpd.replace(" ", "").replace("(","").replace(")","")
    else:
        bstrjobnam = cd.spacegroupsymbol.replace("/","")
    jobnam = ref.cpd.replace(" ", "").replace("(","").replace(")","")
    # If the jobnames are long, replace by the name of the cif file
    if len(bstrjobnam) > 30 and len(cif_file) < len(bstrjobnam)+4:
        bstrjobnam = cif_file.replace(".cif","")
    if len(jobnam) > 10:
        if len(cif_file) < len(jobnam):
            jobnam = cif_file.replace(".cif","")
        else:
            jobnam = jobnam[0:9]
    # Build docstring
    docstring = ref.compound+", "+ref.referencestring()
    # Document details of creation
    programdoc = "Generated by "+programname+" "+version+" "+datestring
        
# Output for TB-LMTO structure constant program bstr
if outputprogram == 'bstr' or outputprogram == 'ncol':
    # Initialize BSTRFile
    bstrfile = BSTRFile(cell, docstring)
    bstrfile.jobnam = bstrjobnam
    bstrfile.a = cd.a
    bstrfile.b = cd.b
    bstrfile.c = cd.c
    # Document program
    bstrfile.programdoc = programdoc
    f = open(bstrjobnam+".dat","w")
    f.write(bstrfile.FileString())
    f.close()
    if outputprogram == 'bstr':
        sys.exit(0)

if outputprogram == 'ncol':
    # Initialize ncolfile
    ncolfile = OldNCOLFile(cell, docstring)
    ncolfile.jobnam = jobnam
    ncolfile.bstrjobnam = bstrjobnam
    # Document program
    ncolfile.programdoc = programdoc
    f = open(jobnam+".dat","w")
    f.write(ncolfile.FileString())
    f.close()
    sys.exit(0)

################################################################################################
# EMTO PROGRAMS
if outputprogram == "emto" or outputprogram == "kgrn" or outputprogram == "kfcd" or outputprogram == "kstr" or outputprogram == "bmdl" or outputprogram == "shape":
    # Get job names
    if cd.spacegroupsymbol == "":
        kstrjobnam = ref.cpd.replace(" ", "").replace("(","").replace(")","")
    else:
        kstrjobnam = cd.spacegroupsymbol.replace("/","")
    kgrnjobnam = ref.cpd.replace(" ", "").replace("(","").replace(")","")
    # If the jobnames are long, replace by the name of the cif file
    if len(kstrjobnam) > 30 and len(cif_file) < len(kstrjobnam)+4:
        kstrjobnam = cif_file.replace(".cif","")
    if len(kgrnjobnam) > 30 and len(cif_file) < len(kgrnjobnam)+4:
        kgrnjobnam = cif_file.replace(".cif","")
    # Build docstring
    docstring = ref.compound+", "+ref.referencestring()
    # Document details of creation
    programdoc = "Generated by "+programname+" "+version+" "+datestring
    # Set the lattice number
    if cd.crystal_system() == "cubic":
        if cd.spacegroupsymbol[0] == "F":
            latticenr = 2
        elif cd.spacegroupsymbol[0] == "I":
            latticenr = 3
        else:
            latticenr = 1
    elif cd.crystal_system() == "hexagonal":
        latticenr = 4
    elif cd.crystal_system() == "tetragonal":
        if cd.spacegroupsymbol == "I":
            latticenr = 6
        else:
            latticenr = 5
    elif cd.crystal_system() == "trigonal":
        latticenr = 7
    elif cd.crystal_system() == "orthorhombic":
        if cd.spacegroupsymbol[0] == "A":
            latticenr = 9
        elif cd.spacegroupsymbol[0] == "B":
            latticenr = 9
        elif cd.spacegroupsymbol[0] == "C":
            latticenr = 9
        elif cd.spacegroupsymbol[0] == "I":
            latticenr = 10
        elif cd.spacegroupsymbol[0] == "F":
            latticenr = 11
        else:
            latticenr = 8
    elif cd.crystal_system() == "monoclinic":
        if cd.spacegroupsymbol[0] == "A":
            latticenr = 13
        elif cd.spacegroupsymbol[0] == "B":
            latticenr = 13
        elif cd.spacegroupsymbol[0] == "C":
            latticenr = 13
        else:
            latticenr = 12
    else:
        # Triclinic and default
        latticenr = 14

# Output for EMTO slope matrix program kstr
if outputprogram == 'kstr' or outputprogram == 'emto':
    # Create directories
    try:
        os.mkdir('kstr')
    except OSError:
        pass
    try:
        os.mkdir('kstr/smx')
    except OSError:
        pass
    # Initialize BSTRFile
    kstrfile = KSTRFile(cell, docstring)
    kstrfile.jobnam = kstrjobnam
    if options.hardsphereradii:
        kstrfile.hardsphere = float(options.hardsphereradii)
    kstrfile.latticenr = latticenr
    kstrfile.a = cd.a
    kstrfile.b = cd.b
    kstrfile.c = cd.c
    kstrfile.alpha = cd.alpha
    kstrfile.beta = cd.beta
    kstrfile.gamma = cd.gamma
    # Document program
    kstrfile.programdoc = programdoc
    f = open("kstr/"+kstrjobnam+".dat","w")
    f.write(kstrfile.FileString())
    f.close()
    if outputprogram == "kstr":
        sys.exit(0)
# Output for EMTO Madelung constant program bmdl
if outputprogram == 'bmdl' or outputprogram == 'emto':
    # Create directories
    try:
        os.mkdir('bmdl')
    except OSError:
        pass
    try:
        os.mkdir('bmdl/mdl')
    except OSError:
        pass
    # Initialize BMDLFile
    bmdlfile = BMDLFile(cell, docstring)
    bmdlfile.jobnam = kstrjobnam
    bmdlfile.latticenr = latticenr
    bmdlfile.a = cd.a
    bmdlfile.b = cd.b
    bmdlfile.c = cd.c
    bmdlfile.alpha = cd.alpha
    bmdlfile.beta = cd.beta
    bmdlfile.gamma = cd.gamma
    # Document program
    bmdlfile.programdoc = programdoc
    f = open("bmdl/"+kstrjobnam+".dat","w")
    f.write(bmdlfile.FileString())
    f.close()
    if outputprogram == "bmdl":
        sys.exit(0)
# Output for EMTO shape function program 'shape'
if outputprogram == 'shape' or outputprogram == 'emto':
    # Create directories
    try:
        os.mkdir('shape')
    except OSError:
        pass
    try:
        os.mkdir('shape/shp')
    except OSError:
        pass
    # Initialize ShapeFile
    shapefile = ShapeFile(cell, docstring)
    shapefile.jobnam = kstrjobnam
    # Document program
    shapefile.programdoc = programdoc
    f = open("shape/"+kstrjobnam+".dat","w")
    f.write(shapefile.FileString())
    f.close()
    if outputprogram == "shape":
        sys.exit(0)
# Output for EMTO main Greens function program 'kgrn'
if outputprogram == 'kgrn' or outputprogram == 'emto':
    # Create directories
    try:
        os.mkdir('kgrn')
    except OSError:
        pass
    try:
        os.mkdir('kgrn/pot')
    except OSError:
        pass
    try:
        os.mkdir('kgrn/chd')
    except OSError:
        pass
    # Initialize KGRNFile
    kgrnfile = KGRNFile(cell, docstring)
    kgrnfile.jobnam = kgrnjobnam
    kgrnfile.kstrjobnam = kstrjobnam
    kgrnfile.latticenr = latticenr
    # Document program
    kgrnfile.programdoc = programdoc
    f = open("kgrn/"+kgrnjobnam+".dat","w")
    f.write(kgrnfile.FileString())
    f.close()
    if outputprogram == "kgrn":
        sys.exit(0)
# Output for EMTO charge density program 'kfcd'
if outputprogram == 'kfcd' or outputprogram == 'emto':
    # Create directories
    try:
        os.mkdir('kfcd')
    except OSError:
        pass
    # Initialize KFCDFile
    kfcdfile = KFCDFile(cell, docstring)
    kfcdfile.jobnam = kgrnjobnam
    kfcdfile.kstrjobnam = kstrjobnam
    # Document program
    kfcdfile.programdoc = programdoc
    f = open("kfcd/"+kgrnjobnam+".dat","w")
    f.write(kfcdfile.FileString())
    f.close()
    if outputprogram == "kfcd":
        sys.exit(0)        
if outputprogram == "emto":
    sys.exit(0)
